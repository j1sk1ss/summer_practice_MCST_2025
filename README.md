# Задания

## 1. Параллельная сортировка массива с использованием pthreads
Написать многопоточную программу на C, использующую библиотеку `pthreads`, для параллельной сортировки массива любым методом.

### Сборка
> make

### Запуск
> ./sorter \<args\>

### Описание решения
За основу был взят алгоритм сортировки "быстрая сортировка". Перед сортировкой, входная последовательность разбивается на чанки, кол-во которых равно кол-ву возможных потоков. Каждый такой чанк проходит сортировку, после чего происходит слияние, алгоритм которого подробно описан в файле `sorter.h`. </br>
Программа самостоятельно генерирует массив случайных чисел. Сам размер массива можно указать через `--arr_size <num>`, и по умолчанию это значение равно `10000`.
Так же программа имеет возможность установки кол-ва потоков. По стандарту это число равно `8`, но может быть изменено путём добавления флага `--max_threads <num>` </br>
На выходе будет распечатам массив с форматированием 10 элементов на строку, и время которое было затрачено на сортировку. </br>
Так же сама сортировка может быть изменена с помощью флагов `--asc` и `--desc`.

------------------------------

## 2. Межпроцессный чат через именованные каналы или сокеты
Реализовать программу на языке C: чат между двумя процессами через именованные каналы (FIFO) или сокеты, используя системные вызовы.

### Сборка
> make

### Запуск
`fifo` - демонстрация работы через FIFO. </br>
`socket` - демонстрация работы через сокеты.
> ./communication <type (fifo / socket)>

### Описание решения
В одном исполнительном файле одновлеменно реализовано два варианта комуникации процессов. Для удобства запуска и наглядной демонстрации, главный процесс делает `fork()`, а далее реализует алгоритм взаимодействия. </br>
При запуске программы с выбором типа комуникации, можно начинать сам процесс обмена сообщениями. Для этого достаточно начать вводить данные в строку.

------------------------------

## 3. Сортировка строк из файла с удалением пустых строк
Написать программу на C. У программы три аргумента командной строки: входной файл, выходной файл, способ сортировки. Отсортировать строки файла указанным способом, удалить пустые строки без видимых символов, вывести результат в выходной файл и на экран.

### Сборка
> make

### Запуск
> ./line_sort \<path\> \<args\>

### Описание решения
Данный исполнительный файл реализует сортировку строк файла по разным паттернам. Перед сортировкой удалаяются все пустые строки и строки с невидимыми символами. </br>
Алгоритм сортировки следующий:
- Токенизация файла. Токен - это одна строка.
- Генерация стека преобразований для каждой строки в зависимости от введённых команд.
- Проход по всем токенам с применением стека преобразований.
- Сортировка с указанным типом (Возрастание и убывание).

Основная идея, что в токене хранится не только сама строка, но и её временная реализация, и числовое значение, по которому будет происходить сортировка. Например при команде `--tlower`, а после `--bylen`, во временную строку запишется строка в нижнем регистре, а по временном числовом значении будет лежать длина строки (длина именно временного представления, если оно есть).</br>
Сама же программа поддерживает следующий набор команд:
```
--bylen Получение длины строки во временное числовое хранение.
--bychar_at <idx> Получение символа из строки по индексу. Само индексирование может быть отрицательным, тогда используется индексирование с конца строки. При выходе за границы, используются крайние (соотвественные края) символы.
--toint Приведение строки к числу (Или к нули, если числа нет).
--letsum Сумма всех букв в строке.
--digsum Сумма всех цифр в строке.
--chsum Сумма всех символов в строке.
--lcount Сумма символов в нижнем регистре.
--ucount Сумма символов в верхнем регистре.
--tlow Приведение строки в нижний регистр.
--tupp Приведение строки в верхний регистр.
--asc Сортировка по возрастанию.
--desc Сортировка по убыванию.
-o Путь для сохранения (Если не указать, будет создан файл типо XXXXXX_<filename>).
```

P.S. Строки, написанные на русском или другом языке из UTF-8 не корректно обрабатываются командами `--tlower` и `--tupper`. Но для русского языка добавлена поддержка кодировки cp1251.

------------------------------

## 4. Парсер аргументов командной строки с использованием getopt и getopt_long
Написать парсер аргументов на языке C. Программа принимает опции `-m`, `-c`, `-s`, `-t`, а также `--elbrus=[1c+, 2c+, 2c3, 4c, 8c, 16c]` и произвольное количество строк без префиксов. Пример:
```
prg -tm -s --elbrus=16c file0 --elbrus=2c3 file1
```
Вывод: `Options are correct: t, m, c, elbrus=16c, elbrus=2c3, non-options: file0, file1.`  
При некорректной опции программа сообщает об ошибке.

### Сборка
> make

### Запуск
> ./parser \<args\>

### Описание решения
Реализованное решение представляет из себя два файла. Это `parser.c` и `parser_old.c`. Дело в том, что изначальное я не достаточно верно прочитал поставленную задачу, и проигнорировал встроенные инструменты `getopt` и `getopt_long`, результатом чего вышел файл `parser_old.c`.

------------------------------

## 5. Демонстрация работы с ошибками системных вызовов
Написать программу на C, которая выполняет системный вызов (например, `open`) и выводит ошибку тремя способами: через `errno`, через массив `sys_errlist[]`, через функцию `perror()`.

### Сборка
> make

### Запуск
> ./error_demo

### Описание решения
Реализованная демонстрация демонстрирует сразу три способа вывода ошибки. Для удобства, так же, можно выбирать какой вид будет выведен. Делается это с помощью флагов `--errlist`, `--perror` и `--errno`. Если же флагов нет, будет продемонстрированно сразу три варианта.

------------------------------

## 6. Получение информации о файлах с помощью stat
Программа на C, принимающая имя файла из командной строки и использующая системный вызов `stat` для вывода справочной информации о файле. Обрабатывать различные типы файлов: обычные, каталоги, специальные байтовые и блочные устройства.

### Сборка
> make

### Запуск
> ./file_stat \<path\>

------------------------------

## 7. Чтение и копирование файла в дочернем и родительском процессах
Программа на C открывает файл (без ограничения по размеру), имя передается через аргумент. После открытия выполняется `fork()`, создаются два файла для записи. Оба процесса читают исходный файл и пишут в свои файлы. После завершения выводится содержимое обоих выходных файлов.

### Сборка
> make

### Запуск
> ./file_copy \<path\>

### Описание решения
Данная программа скопирует файл по пути, который будет передан как первый аргумент. Нюанс работы программы заключается в том, что файлы, по стандарту, будут сохранятся в директории вызова исполнительного файла. Для изменения следует использовать опцию `-o`.

------------------------------

## 8. Умножение матриц с обработкой SIGINT
Программа на C перемножает матрицы 1000x1000 с задержкой 1 секунда на итерацию. При первом сигнале `SIGINT` выводит текущие индексы строк и столбцов, далее восстанавливает поведение по умолчанию. При втором сигнале завершает работу. Реализация через `signal()` и `sigaction()`.

### Сборка
> make

### Запуск
> ./matrix_mul \<sig_type\>

### Описание решения
Для более просто работы с матрицами был реализован ряд фукнций в `matrix.c`. Так же в этом файле и регестрируются сигналы и их обработчики. Главным нюансом реализации является то, что привычный вывод информации во время сигнала является небезопасной практикой, а именно, использование таких функций в асинхронном контексте как `printf`, `exit` и `sprintf` могут привести к дедлокам, излишнему вызову деструкторов, и непредвиденным выделениям памяти. В связи с чем, имеется ряд функций разрешённых к использованию в обработчиках сигналов, например `_exit` и `write`.

------------------------------

## 9. Максимальная возрастающая подпоследовательность с максимальной суммой
Программа на любом языке. Дан одномерный массив случайных целых чисел. Найти максимальную непрерывную возрастающую последовательность с наибольшей суммой элементов.

### Сборка
> make

### Запуск
> ./dp \<path\>

### Описание решения
Для решения поставленно задачи был использован подход динамического программирования. Создаётся временный массив DP, в котором хранится частичная сумма подпоследовательности, пока сами элементы являются возрастающими. </br>
Вывод ответа происходит в консоле. Так же для удобства был сгенерирован файл последовательности `something.txt`.

------------------------------

## 10. Парсер логических выражений
Разработать парсер логических выражений на C или C++, который вычисляет значения переменных. Пример выражения:
```
(A AND B) OR (C AND NOT D)
```

### Сборка
> make

### Запуск
> ./logic_parser \<expression\> \<args\>

### Описание решения
За основу был взят алгоритм моего компилятора `CordellCompiler.EXMPL`, а именно алгоритм токенизации, семантического анализа и генерации логического бинарного дерева. </br>
Сам алгоритм работы следующий:
- Входной текст токенизируется по типам символов (Константы (числа), Неизвестные слова (Буквы), Скобки). Одновременно приводится к нижнему регистру.
- Набор токенов проходит процедуру разметки. `and`, `or`, `not` помечаются соответственными токенами, остальные же буквенные выражения становятся переменными (Переменным одновременно выдаются индекс).
- Размеченные токены проходят процесс семантического анализа, для первычного отсеивания ошибок неверной скобочной последовательности, и неверного синтаксиса по типу:
    - Подряд идущие логические операнды
    - Подряд идущие переменные
    - Идущая переменная перед открытой скобкой.
- После семантического анализа проходит генерация логического бинарного дерева. Саму структуру древа можно увидеть при добавлении параметра `--st`.
- Ответом считается сгенерированная таблица истинности для данного выражения.

------------------------------